#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Threading;

class DefiniteIntegral
{
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsNumber)
    {
        double result = 0.0;
        Barrier barrier = new Barrier(threadsNumber + 1); //создаем барьер для синхронизации потоков
        object resultLock = new object();

        void CalculateArea(object state)
        {
            double trapezoidArea = 0.0;
            double start = (double)state;
            double end = start + (b - a) / threadsNumber;

            //вычисляем площадь трапеции для текущего сегмента с помощью формулы площади трапеции
            for (double x = start; x < end; x += step)
            {
                double nextX = x + step; //следующая точка для текущего сегмента

                if(nextX > end)
                {
                nextX = end;
                }

                trapezoidArea += (function(x) + function(nextX)) * (nextX - x) / 2;
            }

            //обновляем переменную 'result'
            lock (resultLock)
            {
                double currentArea, newArea;
                do
                {
                    currentArea = result;
                    newArea = currentArea + trapezoidArea;
                }
                while (Interlocked.CompareExchange(ref result, newArea, currentArea) != currentArea);
            }

            barrier.SignalAndWait();
        }

        //создаем потоки для каждого сегмента и запускаем их
        for (int i = 0; i < threadsNumber; i++)
        {
            double start = a + i * (b - a) / threadsNumber;
            ThreadPool.QueueUserWorkItem(new WaitCallback(CalculateArea), start);
        }

        barrier.SignalAndWait();
        return result;
    }
        public static double OneThread(Func<double, double> f, double a, double b, double epsilon)
    {
        if (a >= b || epsilon <= 0 || !double.IsNormal(a) || !double.IsNormal(b))
        {
            throw new ArgumentException("Некорректный ввод данных.");
        }

        int steps = (int)((b - a) / epsilon);
        double sum = Enumerable.Range(0, steps)
                               .Select(i => ((f(a + epsilon * i) + f(a + epsilon * (i + 1))) / 2) * epsilon)
                               .Sum();
        return sum;
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);

#!csharp

#r "nuget:ScottPlot, 5.0.35"

using Microsoft.DotNet.Interactive.Formatting;
using System.Diagnostics;

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);

#!csharp

//определяем оптимальный размер шага для вычисления интеграла
Stopwatch sw = new Stopwatch();
Func<double, double> SIN = Math.Sin;

double[] steps = { 1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6 };
double optimalStep = steps[0];
double minTime = double.MaxValue;

foreach (double step in steps)
{
    sw.Restart();
    double result = DefiniteIntegral.Solve(-100, 100, SIN, step, 10);
    sw.Stop();
    double elapsedMilliseconds = sw.Elapsed.TotalMilliseconds;
    Console.WriteLine($"Затрачено времени: {elapsedMilliseconds} мс, размер шага: {step}");

    if (elapsedMilliseconds < minTime)
    {
        minTime = elapsedMilliseconds;
        optimalStep = step;
    }
}

Console.WriteLine($"Оптимальный размер шага: {optimalStep:e}, за время: {minTime} мс");

#!csharp

//измеряем время выполнения многопоточной реализации
Stopwatch sw = new Stopwatch();

var SIN = (double x) => Math.Sin(x);
int testsNumber = 100;
int maxThreadCount = 10;
List<double> results1 = new List<double>();

for (int i = 1; i <= maxThreadCount; i++) 
{
    sw.Start();
    for (int j = 0; j < testsNumber; j++) 
    {
        DefiniteIntegral.Solve(-100, 100, SIN, optimalStep, i);
    }
    sw.Stop();
    results1.Add(sw.ElapsedMilliseconds / (double)testsNumber);
    sw.Restart();
}

//подготовка данных для построения графика и нахождение оптимального числа потоков, при котором функция выполняется за минимальное время
int[] numThreads = Enumerable.Range(1, maxThreadCount).ToArray();
double[] timeValues = results1.ToArray();
double bestResult = timeValues.Min();
double bestNumber = numThreads[results1.IndexOf(bestResult)];

#!csharp

ScottPlot.Plot plot = new();
plot.Add.Scatter(timeValues, numThreads);
plot.XLabel("Время вычисления(мс)");
plot.YLabel("Количество потоков"); 
plot.Title($"Лучшее время: {bestResult} мс");
plot

#!csharp

//измеряем время выполнения однопоточной реализации
Stopwatch sw = new Stopwatch();

List<double> results2 = new List<double>();
double oneThread;
int iterations = 100;

for (int i = 0; i < iterations; i++) 
{
    sw.Start();
    for (int j = 0; j < testsNumber; j++) 
    {
        DefiniteIntegral.OneThread(SIN, -100, 100, optimalStep);
    }
    sw.Stop();
    results2.Add(sw.ElapsedMilliseconds / (double)testsNumber);
    sw.Restart();
}

oneThread = results2.Sum() / (double)iterations;
double diffPercent = Math.Round((oneThread / bestResult - 1) * 100, 2);

#!csharp

//время выполнения многопоточной и однопоточной версий
Console.WriteLine($"Время выполнения многопоточной версии: {bestResult} мс");
Console.WriteLine($"Время выполнения однопоточной версии: {oneThread} мс");

//процентное различие времени выполнения между однопоточной и многопоточной реализациями
Console.WriteLine($"Многопоточная реализация с {bestNumber} потоками на {diffPercent}% быстрее, чем однопоточная");

#!markdown

## Summary

## 1. Оптимальный размер шага
Оптимальный размер шага, обеспечивающий точность 1e-4, был определен как 1e-2. Он был выбран путем измерения времени выполнения для различных шагов и выбора наименьшего времени.

## 2. Оптимальное количество потоков
Среднее значение оптимального количества потоков, при котором достигается минимальное время выполнения многопоточной функции, было определено как 8.

## 3. Сравнение времени выполнения многопоточной и однопоточной версий
Многопоточная реализация в среднем на 130% быстрее, чем однопоточная.
